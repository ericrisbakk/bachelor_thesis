package main.old;/* Generated By:JavaCC: Do not edit this line. TerminusEstV3.java */
import java.io.*;
import java.util.*;

//! -----------------------------------------------------------------

public class TerminusEstV3 implements TerminusEstV3Constants {

        public static Hashtable nameToNum;
        public static Hashtable numToName;

        //! VERSION 3: HASHING IS BY DEFAULT SWITCHED ON
        //! VERSION 2: LOOKUP TABLE FOR ALREADY COMPUTED SOLUTIONS
        public static Hashtable lookup;


        public static Integer intObjects[];

        public static int seenLeaves = 0;

        public static int getLeafNumber( String leaf )
                {
                if( nameToNum == null ) nameToNum = new Hashtable();

                Integer i = (Integer) nameToNum.get( leaf );

                if( i != null )
                        {
                        return i.intValue();
                        }

                seenLeaves++;

                i = new Integer(seenLeaves);

                if( TerminusEstV3.VERBOSE ) System.out.println("** Leaf '"+leaf+"' gets internal number "+seenLeaves);

                nameToNum.put( leaf, i );

                if( numToName == null )
                        {
                        numToName = new Hashtable();
                        }

                numToName.put( i, leaf );

                return seenLeaves;
                }


        public static String getLeafName( int num )
                {
                Integer i = new Integer(num);

                if( numToName == null )
                        {
                        numToName = new Hashtable();
                        }

                String s = (String) numToName.get( i );

                return s;
                }


  public static Tree tree;

  public static Tree current_node;

  private static Tree tn;

  public static int leaves = 0;
  public static int trees = 0;

  public static Tree t1;
  public static Tree t2;

  public static void parseTrees()
        {
        TerminusEstV3 n = new TerminusEstV3(System.in);

        try{ n.Input(); }
        catch( ParseException e )
                {
                System.out.println("Parsing error!");
                e.printStackTrace();
                System.exit(0);
                }

        }

public static String VERSION = "TerminusEstV3.jj Version 3, 30th March 2015";

public final static boolean VERBOSE = false;
public final static boolean BUILD_VERBOSE = false;

//! -------------------------------------
public static boolean USEMINCLUS = true;
public static boolean BUILDNETWORK = true;
public static boolean USEHASH = true;

//! IN VERSION 2 we will remember when this call fails, and put it in a hash table...

public static Network hybNumAtMost( Tree t1, Tree t2, int hyb, Tree origT1, Tree origT2, int depth )
        {
        if(VERBOSE) System.out.println("Entering with hyb="+hyb);

        //! origT1 and origT2 are just passed all the way down, as reference...they are never changed

        if(VERBOSE)
                {
                System.out.println("Tree 1 before collapsing:");
                t1.dump();
                System.out.println();
                System.out.println("Tree 2 before collapsing:");
                t2.dump();
                System.out.println();
                }

        Vector ST = Tree.computeMaxSTsets(t1,t2);

        if( ST.size() == 1 )
                {
                if(VERBOSE) System.out.println("Compatibility detected.");

                long timeEnd = System.currentTimeMillis();
                double seconds =  ((double)(timeEnd - timeNow))/1000.0;

                System.out.println("// -----------------------------");
                System.out.println("// HYBRIDIZATION NUMBER = "+depth);
                System.out.println("// -----------------------------");
                if(BUILDNETWORK==false) System.out.println("// Real-time elapsed in seconds: "+seconds);


                if(BUILDNETWORK == false) System.exit(0);

                Tree.collapseMaxSTsets(t1,t2,ST);

                Network net = null;

                if(t1.isLeaf())
                        {
                        if(BUILD_VERBOSE) System.out.println("Will output MAAF components in hanging-back order (first is the base tree):" );
                        String s[] = getTaxaFromString(t1.name);
                        // for(int p=0; p<s.length; p++) System.out.print("["+s[p]+"] ");
                        // System.out.println();

                        Tree stripT1 = Tree.restrict(origT1, s);
                        Tree stripT2 = Tree.restrict(origT2, s);

                        if(BUILD_VERBOSE)
                                {
                                System.out.print("T1: ");
                                stripT1.dump(); System.out.println(";");

                                System.out.print("T2: ");
                                stripT2.dump(); System.out.println(";");

                                System.out.print("Common binary refinement: ");
                                }

                        Tree commonrf = Tree.commonRefinement(stripT1, stripT2);

                        if(BUILD_VERBOSE)
                                {
                                commonrf.dump(); System.out.println(";");
                                }

                        Tree fakeRoot = new Tree();
                        fakeRoot.addChild(commonrf);
                        commonrf.netParent[0] = fakeRoot;
                        commonrf.netParent[1] = null;

                        net = new Network(fakeRoot);
                        }
                else
                        {
                        System.out.println("ERROR! Compatible ST-set not a leaf.");
                        System.exit(0);
                        }

                return net;
                }

        //! We reach this point if the two trees are not compatible.

        if( hyb == 0 ) return null;     //! is not compatible, because more than 1 max ST-set, but hyb wants 0

        //! -----------------------------------------------
        //! VERSION 2 STARTS HERE....................


        String myBitVec = null;

        if( USEHASH)
        {

        StringBuffer allTaxa = new StringBuffer();

        for(int x=0;x<ST.size();x++)
                {
                STset s = (STset) ST.elementAt(x);
                int count[] = new int[1];
                String t = s.getTaxaString(count);
                allTaxa.append(t);
                //! System.out.println("max ST set "+x+" contains taxa "+t);
                //! System.out.println(count[0]);
                }

        StringBuffer stripped = new StringBuffer();
        String back = allTaxa.toString();
        String forth = back.trim();
        allTaxa = new StringBuffer( forth );

        for(int x=0; x<allTaxa.length(); x++ )
                {
                char c = allTaxa.charAt(x);

                if( (c == '{') || (c=='}') ) continue;

                if( c == ' ' )
                        {
                        //! Only add a character to the end of stripped if there isn't one there already...
                        if( stripped.length() < 1 ) continue;
                        if( stripped.charAt( stripped.length() - 1 ) == ' ' ) continue;
                        }

                stripped.append(c);
                }

        String taxaList[] = stripped.toString().split(" ");


        if(VERBOSE)
        {
        System.out.println(" ---- TAXA AT THIS ITERATION --- ");
        for(int x=0; x<taxaList.length; x++)
                {
                System.out.println(taxaList[x] + " = " + getLeafNumber(taxaList[x]));
                }
        }

        //! This is going to become a bit vector denoting which taxa we have.
        boolean got[] = new boolean[ seenLeaves + 1 ];

        for(int x=0; x<taxaList.length; x++)
                {
                int tick = getLeafNumber(taxaList[x]);
                got[tick] = true;
                }

        StringBuffer bitVec = new StringBuffer();
        for(int x=1; x<=seenLeaves; x++ )
                {
                if( got[x] ) bitVec.append('1');
                else bitVec.append('0');
                }

        myBitVec = bitVec.toString();

        if(VERBOSE)
                {
                System.out.println("Bit vector = "+myBitVec);
                }

        //! Check whether there is already a fail-recording in the hashtable.

        Integer failInt = (Integer) lookup.get(myBitVec);

        if( failInt != null )
                {
                int bound = failInt.intValue();

                //! THis means that this input is known to not have a hybridization number >= bound.

                if( bound >= hyb )
                        {
                        //! WE CAN TERMINATE IMMEDIATELY...
                        if(VERBOSE) System.out.println("HASHTABLE HIT! Terminating this search branch.");
                        return null;
                        }

                }

        } //! end if(USEHASH)

        //! --------------------------------------------------------------------

        Tree.collapseMaxSTsets(t1,t2,ST);

        if(VERBOSE)
                {
                System.out.println("Tree 1 after collapsing:");
                t1.dump();
                System.out.println();
                System.out.println("Tree 2 after collapsing:");
                t2.dump();
                System.out.println();
                }


        Vector taxa = new Vector();
        t1.getLeafDescendants(taxa);

        Hashtable ht = new Hashtable();

        Tree numToTaxonT1[] = new Tree[taxa.size()];
        Tree numToTaxonT2[] = new Tree[taxa.size()];

        for(int x=0; x<taxa.size(); x++)
                {
                Tree leaf = (Tree) taxa.elementAt(x);
                leaf.num = x;   //! This assigns a number to the leaf.
                numToTaxonT1[x] = leaf;
                ht.put( leaf.name, leaf );      //! So we can find the corresponding node in the second tree
                }

        Vector taxaSecondTree = new Vector();
        t2.getLeafDescendants(taxaSecondTree);

        if( taxaSecondTree.size() != taxa.size() )
                {
                System.out.println("Catastrophic error. Trees have different numbers of taxa.");
                System.exit(0);
                }

        int n = taxa.size();

        for(int x=0; x<n; x++)
                {
                Tree leaf = (Tree) taxaSecondTree.elementAt(x);

                Tree co = (Tree) ht.get(leaf.name);
                if( co == null )
                        {
                        System.out.println("Catastrophic error. Couldn't find taxon from second tree in first tree.");
                        System.exit(0);
                        }
                if( !leaf.name.equals(co.name) )
                        {
                        System.out.println("Catastrophic error. Hashing problem lining up taxa.");
                        System.exit(0);
                        }
                leaf.num = co.num;
                numToTaxonT2[leaf.num] = leaf;
                }

        t1.buildClusters( n );
        t2.buildClusters( n );

        //! --------------------------------------------

        //! Ok, now let's count the terminals...

        int terminals = 0;
        Vector termVec = new Vector();

        boolean isTerminal[] = new boolean[n];

        for( int x=0; x<n; x++ )
                {
                Tree u = numToTaxonT1[x].parent;
                Tree v = numToTaxonT2[x].parent;

                int intersect = 0;
                for( int y=0; y<n; y++ )
                        {
                        if( u.cluster[y] && v.cluster[y] ) intersect++;
                        if( intersect > 1 ) break;
                        }
                if( intersect == 0 )
                        {
                        System.out.println("Catastrophic error, somehow a taxon is not in the intersection of its witness sets.");
                        System.exit(0);
                        }
                if( intersect == 1 )
                        {
                        terminals++;
                        if( VERBOSE ) System.out.println(numToTaxonT1[x].name+" is a terminal.");
                        termVec.addElement( numToTaxonT1[x] );  //! records it's position in T1
                        isTerminal[x] = true;   //! let's us quickly determine if something is a terminal
                        }

                }

        if(VERBOSE) System.out.println(terminals+" terminals in total!");

        //! ----------------------------------------------------------------

        if( terminals > 3*hyb )
                {
                if(VERBOSE) System.out.println("Naive 3*hyb terminal bound violated.");

                //! PUT IT IN THE HASHTABLE
                if(USEHASH) lookup.put( myBitVec, intObjects[hyb] );

                return null;
                }

        Vector guessSet = taxa;

        boolean SeenTwoClus = false;

        //! ----------------------------------------------
        //! Check whether there are two conflicting size-2 clusters

        outerWall: for(int x=0; x<termVec.size(); x++ )
                {
                Tree termT1 = (Tree) termVec.elementAt(x);

                int look = termT1.num;

                Tree termT2 = numToTaxonT2[look];

                int look2 = -1;
                int look3 = -1;

                Tree pt1 = termT1.parent;
                Tree pt2 = termT2.parent;

                int c1size = 0;
                int c2size = 0;

                boolean union[] = new boolean[ pt1.cluster.length ];

                for(int y=0; y<pt1.cluster.length; y++ )
                        {
                        if( pt1.cluster[y] ) c1size++;
                        if( pt2.cluster[y] ) c2size++;
                        union[y] = pt1.cluster[y] || pt2.cluster[y];
                        if( (c1size > 2) || (c2size > 2) ) break;
                        }

                if( (c1size == 2) && (c2size == 2) )
                        {
                        SeenTwoClus = true;
                        guessSet = new Vector();

                        int check = 0;
                        for( int m=0; m<union.length; m++ )
                                {
                                if( union[m] )
                                        {
                                        guessSet.addElement( numToTaxonT1[m] );
                                        if(VERBOSE) System.out.println("2-CONFLICT: "+numToTaxonT1[m].name );
                                        check++;
                                        }
                                }
                        if( check != 3 )
                                {
                                System.out.println("Catastrophic error. Claimed to have found two conflicting size-2 clusters but didn't get 3 taxa.");
                                System.exit(0);
                                }
                        break outerWall;
                        }

                }

        //! -----------------------------------------------

        boolean BrokenTwoBound = false;

        if(!SeenTwoClus)
                {
                if( terminals > (2*hyb) )
                        {
                        BrokenTwoBound = true;
                        if(VERBOSE) System.out.println("More than 2*hyb terminals, taking the first (2*hyb)+1...");
                        guessSet = new Vector();
                        for(int x=0; x<=(2*hyb); x++ )
                                {
                                guessSet.addElement( termVec.elementAt(x) );
                                }

                        // In the algorithm on paper, designed for optimizing worst-case performance, we can just use
                        //! this 2r+1 guess-set. But here we wait to see if the guess set derived from minimum clusters is
                        //! smaller.
                        }
                }

        if((!SeenTwoClus) && USEMINCLUS)
                {
                //! Ok, let's build the stuff from minimal clusters...

                Vector v1 = new Vector();
                Vector v2 = new Vector();

                boolean hitSet[] = new boolean[n];

                t1.harvestLocalMinimal(v1);
                t2.harvestLocalMinimal(v2);

                if(VERBOSE) System.out.println(v1.size()+" quasi-minimal in T1");
                if(VERBOSE) System.out.println(v2.size()+" quasi-minimal in T2");

                buiten: for(int y=0; y<v1.size(); y++)
                        {
                        Tree node1 = (Tree) v1.elementAt(y);

                        if(VERBOSE)
                        {
                        System.out.println("Quasi minimal cluster "+y+" from T1:");
                        for(int r=0; r<node1.cluster.length; r++ )
                                {
                                if( node1.cluster[r] )
                                        {
                                        System.out.print( numToTaxonT1[r].name + " ");
                                        }
                                }
                        if(VERBOSE) System.out.println();
                        }

                        //! Check that none of the T2 clusters are inside it.

                        binnen: for(int z=0; z<v2.size(); z++ )
                                {
                                Tree node2 = (Tree) v2.elementAt(z);

                                for(int q=0; q<n; q++ )
                                        {
                                        if( node2.cluster[q] && (!node1.cluster[q]) ) continue binnen;
                                        }
                                continue buiten;
                                }
                        //! Ok, we can now take 2 taxa from this cluster...

                        int toDo = 2;
                        boolean gotTerminal = false;

                        for( int z=0; z<node1.cluster.length; z++ )
                                {
                                if( toDo == 0 ) break;
                                if( !node1.cluster[z] ) continue;
                                if( isTerminal[z] )
                                        {
                                        hitSet[z] = true;
                                        gotTerminal = true;
                                        toDo--;
                                        continue;
                                        }
                                if( (toDo == 2) || gotTerminal )
                                        {
                                        hitSet[z] = true;
                                        toDo--;
                                        continue;
                                        }
                                }
                        }

                        outer: for(int y=0; y<v2.size(); y++)
                        {
                        Tree node1 = (Tree) v2.elementAt(y);

                        //! Check that none of the T1 clusters are inside it.

                        if(VERBOSE)
                        {
                        System.out.println("Quasi minimal cluster "+y+" from T2:");
                        for(int r=0; r<node1.cluster.length; r++ )
                                {
                                if( node1.cluster[r] )
                                        {
                                        System.out.print( numToTaxonT2[r].name + " ");
                                        }
                                }
                        System.out.println();
                        }

                        inner: for(int z=0; z<v1.size(); z++ )
                                {
                                Tree node2 = (Tree) v1.elementAt(z);

                                for(int q=0; q<n; q++ )
                                        {
                                        if( node2.cluster[q] && (!node1.cluster[q]) ) continue inner;
                                        }
                                continue outer;
                                }
                        //! Ok, we can now take 2 taxa from this cluster...

                        int toDo = 2;
                        boolean gotTerminal = false;

                        for( int z=0; z<node1.cluster.length; z++ )
                                {
                                if( toDo == 0 ) break;
                                if( !node1.cluster[z] ) continue;
                                if( isTerminal[z] )
                                        {
                                        hitSet[z] = true;
                                        gotTerminal = true;
                                        toDo--;
                                        continue;
                                        }
                                if( (toDo == 2) || gotTerminal )
                                        {
                                        hitSet[z] = true;
                                        toDo--;
                                        continue;
                                        }
                                }
                        }

                int hitCount = 0;
                for(int w=0; w<hitSet.length; w++ )
                        {
                        if( hitSet[w] ) hitCount++;
                        }
                if(VERBOSE) System.out.println("HittingSet has size "+hitCount);
                if(VERBOSE) System.out.println("Previous guessSet has size "+guessSet.size());
                if( hitCount < guessSet.size() )
                        {
                        if(VERBOSE) System.out.println("WE IMPROVED!");
                        guessSet = new Vector();
                        for(int span=0; span<hitSet.length; span++ )
                                {
                                if(hitSet[span]) guessSet.addElement( numToTaxonT1[span] );
                                }
                        }

                }

        //! ---------------------------------------------------------------------------
        if(VERBOSE) System.out.println(guessSet.size()+" taxa to consider deleting.");

        for( int m=0; m<guessSet.size(); m++ )
                {
                Tree del = (Tree) guessSet.elementAt(m);
                if(VERBOSE) System.out.println("Deleting taxon "+del.name);

                String zoekNaam = del.name;

                Tree alpha[] = new Tree [1];
                Tree beta[] = new Tree [1];


                Tree newGuyA = t1.copy(alpha,zoekNaam);
                Tree newGuyB = t2.copy(beta, zoekNaam);

                // System.out.println("NewGuyA... "+alpha[0].name);
                // System.out.println("NewGuyB... "+beta[0].name);

                Tree killA = alpha[0].delete();
                if( killA != null )
                                {
                                if(VERBOSE) System.out.println("New root in T1...");
                                }
                        else killA = newGuyA;


                Tree killB = beta[0].delete();

                if( killB != null )
                                {
                                if(VERBOSE) System.out.println("New root in T2...");
                                }
                        else killB = newGuyB;

                if(VERBOSE)
                        {
                        killA.dump();
                        System.out.println();
                        }
                if(VERBOSE)
                        {
                        killB.dump();
                        System.out.println();
                        }

                Network net = null;
                net = hybNumAtMost( killA, killB, hyb-1, origT1, origT2, depth+1 );

                if( net != null )
                        {
                        String s[] = getTaxaFromString(del.name);
                        //! for(int p=0; p<s.length; p++) System.out.print("["+s[p]+"] ");
                        //! System.out.println();

                        Tree stripT1 = Tree.restrict(origT1, s);
                        Tree stripT2 = Tree.restrict(origT2, s);

                        if(BUILD_VERBOSE)
                                {
                                System.out.print("T1: ");
                                stripT1.dump(); System.out.println(";");

                                System.out.print("T2: ");
                                stripT2.dump(); System.out.println(";");

                                System.out.print("Common binary refinement: ");
                                }

                        Tree commonrf = Tree.commonRefinement(stripT1, stripT2);

                        if(BUILD_VERBOSE)
                                {
                                commonrf.dump(); System.out.println(";");
                                }

                        //! graft him onto the old network...
                        //! first we need to have the union of the two taxa sets...

                        Hashtable old = net.getTaxa();

                        Hashtable newTaxa = new Hashtable();

                        for(int y=0; y<s.length; y++)
                                {
                                newTaxa.put(s[y],s[y]);
                                }
                        Enumeration e = old.keys();
                        while( e.hasMoreElements() )
                                {
                                String k = (String) e.nextElement();
                                newTaxa.put(k,k);
                                }

                        //! newTaxa now contains the union of the network taxa and the new guy to be grafted on...
                        //! -----------------------------

                        Tree locate[] = new Tree[2];

                        locate[0] = Tree.restrict(origT1, newTaxa);
                        locate[1] = Tree.restrict(origT2, newTaxa);

                        int t = newTaxa.size();

                        Hashtable zoekClus[] = new Hashtable[2];

                        for(int loop=0; loop<2; loop++)
                                {
                                int counter[] = new int[1];
                                counter[0] = 0;

                                //! Build the 0 -> n-1 numbering, build the vertex clusters,
                                //! get the leaf numbers of the to-graft taxa, put them in a search vector...

                                locate[loop].assignLeafNumbersBuildClusters(t, counter);

                                Hashtable l = locate[loop].getLeafToTreeMapping();

                                boolean zoek[] = new boolean[t];

                                for(int scan=0; scan<s.length; scan++)
                                        {
                                        Tree node = (Tree) l.get(s[scan]);
                                        zoek[ node.num ] = true;
                                        }

                                //! Find an arbitrary starting point in the subtree we are grafting on
                                Tree bottom = locate[loop].findLeaf(s[0]);

                                //! Work up the tree until we have a vertex cluster that is a (not nec. strict) superset of 's'
                                while( !Tree.superset(bottom.cluster,zoek) ) bottom = bottom.parent;

                                //! Now, we've found the LCA...what now....
                                Tree lca = bottom;

                                //! if the lca cluster is exactly equal to the zoek cluster, go one higher.
                                if( Tree.equalTo(lca.cluster,zoek) )
                                        {
                                        lca = lca.parent;
                                        }

                                Hashtable difference = new Hashtable();

                                Hashtable donotWant = new Hashtable();
                                for(int x=0; x<s.length;x++ ) donotWant.put(s[x],s[x]);

                                lca.getDifference( donotWant, difference );

                                zoekClus[loop] = difference;    //! This is the cluster we need to look for in the network

                                }

                        //! Now we need to find out the re-grafting points



                        net.buildLeftRightClusters();

                        //! Ok, so now the pre-graft network has the vertex clusters for the two trees inside its nodes.

                        Tree graftAbove[] = new Tree[2];

                        for(int tree=0; tree<2; tree++)
                                {
                                boolean kijkClus[] = new boolean[net.currentTaxa];

                                Enumeration k = zoekClus[tree].keys();

                                String nom = null;

                                while(k.hasMoreElements())
                                        {
                                        nom = (String) k.nextElement();
                                        Tree netL = net.getNetworkLeaf(nom);
                                        int code = netL.num;
                                        kijkClus[code] = true;
                                        }

                                //! So kijkClus has now got the correct numbering for the network
                                //! The last 'nom' is fine...

                                Tree base = net.getNetworkLeaf(nom);

                                while( !Tree.superset(base.netClus[tree], kijkClus) )
                                                {
                                                if( base.netParent[1] == null )
                                                        {
                                                        //! split node
                                                        base = base.netParent[0];
                                                        }
                                                else
                                                        {
                                                        //! reticulation
                                                        base = base.netParent[tree];
                                                        }
                                                }
                                graftAbove[tree] = base;
                                }

                        //! System.out.println("About to graft component onto network...");

                        if( graftAbove[0] == graftAbove[1] )
                                {
                                System.out.println("CATASTROPHIC ERROR: It should never be necessary to graft two retic edges on the same edge.");
                                System.exit(0);
                                }

                        if( (graftAbove[0].netParent[1] != null) || (graftAbove[1].netParent[1] != null) )
                                {
                                System.out.println("CATASTROPHIC ERROR: It should never be necessary to graft on a reticulation edge.");
                                System.exit(0);
                                }

                        Tree retic = new Tree();
                        retic.addChild( commonrf );     //! single child
                        commonrf.netParent[0] = retic;
                        commonrf.netParent[1] = null;

                        for(int graft=0;graft<2; graft++)
                                {
                                Tree target = graftAbove[graft];

                                Tree inbetween = new Tree();
                                inbetween.addChild(target);
                                inbetween.addChild(retic);
                                retic.netParent[graft] = inbetween;

                                inbetween.netParent[0] = target.netParent[0];
                                inbetween.netParent[1] = null;

                                target.netParent[0] = inbetween;
                                target.netParent[1] = null;

                                inbetween.netParent[0].deleteChild(target);
                                inbetween.netParent[0].addChild(inbetween);
                                }

                        net.resetNetwork();

                        return net;
                        }
                }

        //! PUT IT IN THE HASHTABLE
        if(USEHASH) lookup.put( myBitVec, intObjects[hyb] );
        return null;
        }

  public static String[] getTaxaFromString(String s)
        {
                        String a = s.replace('{',' ');
                        String b = a.replace('}',' ');

                        StringBuffer clean = new StringBuffer();

                        int at=0;
                        boolean wasSpace = true;

                        for(int x=0; x<b.length();x++)
                                {
                                if( b.charAt(x) == ' ')
                                        {
                                        if(!wasSpace) clean.append(' ');
                                        wasSpace = true;
                                        }
                                else
                                        {
                                        clean.append(b.charAt(x));
                                        wasSpace = false;
                                        }
                                }

        if(clean.charAt(clean.length()-1) == ' ') clean.deleteCharAt(clean.length()-1);
        String t = clean.toString();

        return t.split(" ");

        }


  public static long timeNow = 0;

  public static void main(String args[])
        {

        if( args.length != 0 )
                {
                        if( args[0].equals("-help") )
                                {
                                System.out.println("// Usage: java TerminusEstV3 [optional switches] < treeFile.txt");
                                System.out.println("// Optional switches:");
                                System.out.println("// -nonetwork : only compute hybridization number, do not generate a network. (The default is to generate a network.)");
                                System.out.println("// -nohash : do not use look-up table to store intermediate solutions. (The default is to use the hash table, which potentially uses an exponential amount of memory.");
                                System.exit(0);
                                }

                }

        System.out.println("// This is TerminusEstV3, version 30th March 2015.");
        System.out.println("// Usage: java TerminusEstV3 [optional switches] < treeFile.txt");
        System.out.println("// (If the program seems to have hung, you have probably");
        System.out.println("// forgotten the '<' operator).");
        System.out.println("// -------------------------------------");


        parseTrees();

        System.out.println("// We saw "+TerminusEstV3.seenLeaves+" taxa in total.");


        //! ----- This is just so we don't have to constantly create new Integer() objects for the lookup hashtable
        intObjects = new Integer [seenLeaves+1];

        for(int x=0; x<intObjects.length; x++ )
                {
                intObjects[x] = new Integer(x);
                }
        //! ------------------------------------

        lookup = new Hashtable();

        if(VERBOSE)
                {
                System.out.println("// Finished reading the two trees in.");
                System.out.println("// The trees are now stored internally as follows");

                t1.dump();
                System.out.println(";");

                t2.dump();
                System.out.println(";");
                }

        if( args.length != 0 )
                {
                for(int x=0; x<args.length; x++ )
                        {
                        if( args[x].equals("-nonetwork") )
                                {
                                System.out.println("// -nonetwork switch seen: will only compute reticulation number, will not build a network.");
                                BUILDNETWORK = false;
                                }
                        else
                        if( args[x].equals("-nohash") )
                                {
                                System.out.println("// -nohash switch seen: will not use a look-up table to remember intermediate solutions.");
                                USEHASH = false;
                                }
                        }
                }

        timeNow = System.currentTimeMillis();


        System.out.print("// SETTING: ");
        if(BUILDNETWORK) System.out.println("A network WILL be constructed.");
        else System.out.println("A network will NOT be constructed.");

        System.out.print("// SETTING: ");
        if(USEHASH) System.out.println("Hash tables WILL be used.");
        else System.out.println("Hash tables will NOT be used.");


        for( int l=0; l <= TerminusEstV3.seenLeaves; l++ )
                {
                Tree T1 = t1.copy(null,null);
                Tree T2 = t2.copy(null,null);

                System.out.println("// Trying r="+l);
                Network net = hybNumAtMost( T1, T2, l, t1, t2, 0 );
                if( net != null )
                        {
                        //! get rid of the fake root

                        if( net.root.children.size() != 1 )
                                {
                                System.out.println("CATASTROPHIC ERROR, we lost the fake root...");
                                System.exit(0);
                                }

                        long timeEnd = System.currentTimeMillis();
                        double seconds =  ((double)(timeEnd - timeNow))/1000.0;

                        net.root = (Tree) net.root.children.elementAt(0);

                        net.resetNetwork();

                        net.root.dumpNetwork();
                        net.root.dumpNetworkTreeImage(0);
                        net.root.dumpNetworkTreeImage(1);

                        net.root.dumpEnewick();

                        //! ------------------- As a final check, check that the trees are actually displayed

                        net.buildLeftRightClusters();

                        boolean success = false;
                        success = net.checkDisplay( t1, 0 );
                        if(!success)
                                {
                                System.out.println("CATASTROPHIC ERROR, first tree not displayed by the network.");
                                System.exit(0);
                                }
                        else System.out.println("// First tree displayed by network!");

                        success = net.checkDisplay( t2, 1 );
                        if(!success)
                                {
                                System.out.println("CATASTROPHIC ERROR, second tree not displayed by the network.");
                                System.exit(0);
                                }
                        else System.out.println("// Second tree displayed by network!");



                        System.out.println("// -----------------------------");
                        System.out.println("// HYBRIDIZATION NUMBER = "+l);
                        System.out.println("// -----------------------------");
                        System.out.println("// Real-time elapsed in seconds: "+seconds);

                        //! Finished!
                        System.exit(0);
                        }
                }


        }

  static final public void Input() throws ParseException {
  String s;
  double len;
    label_1:
    while (true) {
      if (jj_2_1(2)) {
        ;
      } else {
        break label_1;
      }
    tree = new Tree(); current_node = tree; leaves = 0;
      descendant_list();
      if (jj_2_2(2)) {
        s = label();

      } else {
        ;
      }
      if (jj_2_3(2)) {
        jj_consume_token(7);
        len = branch_length();
      } else {
        ;
      }
      jj_consume_token(8);
        if( trees == 0 )
                {
                // System.out.println("** Read(ing) tree 1...");
                t1 = tree;
                }
        else
        if( trees == 1 )
                {
                // System.out.println("** Read(ing) tree 2...");
                t2 = tree;
                }
        else
                {
                System.out.println("ERROR! We can only deal with two trees.");
                System.exit(0);
                }
        trees++;
    }
    jj_consume_token(0);

  }

  static final public void descendant_list() throws ParseException {
  int children = 0;
    jj_consume_token(9);
        children++;
        tn = new Tree();
        tn.setParent(current_node);
        current_node.addChild(tn);
        current_node = tn;
    subtree();
    label_2:
    while (true) {
      if (jj_2_4(2)) {
        ;
      } else {
        break label_2;
      }
      jj_consume_token(10);
          children++;
          tn = new Tree();
          tn.setParent(current_node);
          current_node.addChild(tn);
          current_node = tn;
      subtree();
    }
    jj_consume_token(11);
  }

/** function subtree will set name, length and weight for each tree node */
  static final public void subtree() throws ParseException {
  String s;
  double len;
    if (jj_2_9(2)) {
      descendant_list();

      if (jj_2_5(2)) {
        s = label();

      } else {
        ;
      }
      if (jj_2_6(2)) {
        jj_consume_token(7);
        len = branch_length();

      } else {
        ;
      }
         current_node = current_node.getParent();
    } else {
      if (jj_2_7(2)) {
        s = label();
                  leaves++;
                int x = getLeafNumber(s);
                current_node.setName(s);
                current_node.setNumber(x);
      } else {
        ;
      }
      if (jj_2_8(2)) {
        jj_consume_token(7);
        len = branch_length();

      } else {
        ;
      }
  current_node = current_node.parent;
    }
  }

  static final public String label() throws ParseException {
  String s;
    if (jj_2_10(2)) {
      s = unquoted_label();
                         {if (true) return s;}
    } else if (jj_2_11(2)) {
      s = quoted_label();
                       {if (true) return s;}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/** for each unquoted label, we need to replace '_' by ' ' */
  static final public String unquoted_label() throws ParseException {
  Token t;
    if (jj_2_12(2)) {
      t = jj_consume_token(unquoted_string);
                          String s = new String(t.toString());
                                {if (true) return s;}
                          // return s.replace('_', ' ');

    } else if (jj_2_13(2)) {
      t = jj_consume_token(double_number);
                        {if (true) return new String(t.toString());}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/** for each quoted label, we remove double quotes from the string */
  static final public String quoted_label() throws ParseException {
  Token t;
    t = jj_consume_token(quoted_string);
                        String s = new String(t.toString());
                        {if (true) return s.substring(1, s.length()-1);}
    throw new Error("Missing return statement in function");
  }

  static final public double branch_length() throws ParseException {
  Token t;
    t = jj_consume_token(double_number);
                        {if (true) return Double.parseDouble(t.toString());}
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  static private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  static private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  static private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  static private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  static private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  static private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  static private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  static private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  static private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  static private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  static private boolean jj_3_8() {
    if (jj_scan_token(7)) return true;
    if (jj_3R_5()) return true;
    return false;
  }

  static private boolean jj_3_7() {
    if (jj_3R_4()) return true;
    return false;
  }

  static private boolean jj_3R_9() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_7()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3_8()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3_6() {
    if (jj_scan_token(7)) return true;
    if (jj_3R_5()) return true;
    return false;
  }

  static private boolean jj_3_5() {
    if (jj_3R_4()) return true;
    return false;
  }

  static private boolean jj_3_9() {
    if (jj_3R_3()) return true;
    return false;
  }

  static private boolean jj_3R_6() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_9()) {
    jj_scanpos = xsp;
    if (jj_3R_9()) return true;
    }
    return false;
  }

  static private boolean jj_3R_5() {
    if (jj_scan_token(double_number)) return true;
    return false;
  }

  static private boolean jj_3R_8() {
    if (jj_scan_token(quoted_string)) return true;
    return false;
  }

  static private boolean jj_3_3() {
    if (jj_scan_token(7)) return true;
    if (jj_3R_5()) return true;
    return false;
  }

  static private boolean jj_3_2() {
    if (jj_3R_4()) return true;
    return false;
  }

  static private boolean jj_3_13() {
    if (jj_scan_token(double_number)) return true;
    return false;
  }

  static private boolean jj_3_1() {
    if (jj_3R_3()) return true;
    return false;
  }

  static private boolean jj_3_4() {
    if (jj_scan_token(10)) return true;
    if (jj_3R_6()) return true;
    return false;
  }

  static private boolean jj_3R_7() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_12()) {
    jj_scanpos = xsp;
    if (jj_3_13()) return true;
    }
    return false;
  }

  static private boolean jj_3_12() {
    if (jj_scan_token(unquoted_string)) return true;
    return false;
  }

  static private boolean jj_3R_3() {
    if (jj_scan_token(9)) return true;
    if (jj_3R_6()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_4()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(11)) return true;
    return false;
  }

  static private boolean jj_3_11() {
    if (jj_3R_8()) return true;
    return false;
  }

  static private boolean jj_3_10() {
    if (jj_3R_7()) return true;
    return false;
  }

  static private boolean jj_3R_4() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_10()) {
    jj_scanpos = xsp;
    if (jj_3_11()) return true;
    }
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public TerminusEstV3TokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[0];
  static private int[] jj_la1_0;
  static {
      jj_la1_init_0();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {};
   }
  static final private JJCalls[] jj_2_rtns = new JJCalls[13];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public TerminusEstV3(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public TerminusEstV3(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new TerminusEstV3TokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public TerminusEstV3(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new TerminusEstV3TokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public TerminusEstV3(TerminusEstV3TokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(TerminusEstV3TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[25];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 0; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 25; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 13; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}

//! -----------------------------------------------------------------

class Network
        {
        Hashtable mapNameToLeaf;        //! also functions as a set of taxa...this should be
                                                                //! invariant i.e. always correct!
        Tree root;

        int currentTaxa;

        public Network( Tree top )
                {
                this.root = top;
                resetNetwork();
                }

        public void resetNetwork()
                {
                mapNameToLeaf = new Hashtable();

                int count[] = new int[1];
                count[0] = 0;

                root.cleanNetwork(mapNameToLeaf, count);

                currentTaxa = count[0];

                if(TerminusEstV3.BUILD_VERBOSE) System.out.println("Network currently has "+currentTaxa+" taxa.");
                }

        public Hashtable getTaxa()
                {
                return mapNameToLeaf;
                }

        public boolean checkDisplay(Tree t, int which)
                {
                Tree safe = t.copy(null,null);

                t.renumber(mapNameToLeaf);      //! makes sure the 'num' values are synchronised with the network
                t.buildClusters(currentTaxa);

                //! This bit is extremely lazy...

                Vector harvestNet = new Vector();
                this.root.harvestNetClus(harvestNet,which);

                Vector harvestTree = new Vector();
                t.harvestTreeClus(harvestTree);

                funky: for(int l=0; l<harvestTree.size(); l++)
                        {
                        boolean cl[] = (boolean[]) harvestTree.elementAt(l);

                        for(int m=0; m<harvestNet.size(); m++)
                                {
                                boolean compare[] = (boolean[]) harvestNet.elementAt(m);
                                if( Tree.equalTo(compare,cl) )
                                        {
                                        continue funky; //! found it!
                                        }
                                }
                        return false;   //! couldn't find the cluster in the network
                        }

                return true;
                }

        public Tree getNetworkLeaf(String s)
                {
                return( (Tree) mapNameToLeaf.get(s) );
                }

        //! make sure that currentTaxa is correct...

        public void buildLeftRightClusters()
                {
                for(int tree=0; tree<2; tree++ )
                        {
                        root.buildOneSidedClusters(tree, currentTaxa);
                        }

                }

        }

//! ---------------------------------------------------------------

class Tree
        {
        Tree parent;
        Vector children;
        boolean isLeaf;

        //! This is only for taxa...
        String name;
        int num;

        //! ----- data under here does not get cloned...

        boolean cluster[];

        //! ---------------------------------------------

        Tree netParent[];       //! A size-2 array, the at most two parents in the network
                                                //! only used in the constructive phase of the algorithm...
        boolean visited;
        boolean netClus[][];
        int printNum;

        //! ----------------------------------------------

        int hybLabel;

        //! ----------------------------------------------

        public Tree()
                {
                isLeaf = false;
                parent = null;
                children = null;

                //! Things only relevant for taxa...
                name = null;
                num = -1;

                netParent = new Tree[2];
                }

public void harvestTreeClus(Vector harvest)
        {
        if( this.isLeaf() )
                {
                harvest.addElement( cluster );
                }
        else
                {
                harvest.addElement( cluster );
                for(int x=0; x<children.size(); x++ )
                        {
                        Tree child = (Tree) children.elementAt(x);
                        child.harvestTreeClus(harvest);
                        }
                }

        }

public void harvestNetClus(Vector harvestNet, int tree)
        {
        if( this.isLeaf() )
                {
                harvestNet.addElement( netClus[tree] );
                }
        else
                {
                harvestNet.addElement( netClus[tree] );

                for(int x=0; x<children.size(); x++ )
                        {
                        Tree child = (Tree) children.elementAt(x);

                        if( child.netParent[0] == this ) child.harvestNetClus(harvestNet, tree);        //! has the effect of only visiting
                                                                                                                                                                //! treenodes and reticulations via their left edge
                        }
                }
        }

public void renumber( Hashtable netMap )
        {
        if( this.isLeaf() )
                {
                Tree netNode = (Tree) netMap.get(name);
                int newNum = netNode.num;
                this.num = newNum;
                }
        else
                {
                for(int x=0; x<children.size(); x++ )
                        {
                        Tree child = (Tree) children.elementAt(x);
                        child.renumber(netMap);
                        }
                }
        }

public void getDifference( Hashtable donotWant, Hashtable diff )
        {
        if( this.isLeaf() )
                {
                String check = (String) donotWant.get(this.name);
                if( check == null ) diff.put(this.name, this.name);
                }
        else
                {
                for(int x=0; x<children.size(); x++ )
                        {
                        Tree child = (Tree) children.elementAt(x);
                        child.getDifference(donotWant, diff);
                        }
                }
        }

//! returns true if v1 is a superset of v2
public static boolean superset(boolean v1[], boolean v2[])
        {
        for(int x=0; x<v1.length; x++)
                {
                if(v2[x] && (!v1[x])) return false;
                }
        return true;
        }

public static boolean equalTo(boolean v1[], boolean v2[])
        {
        for(int x=0; x<v1.length; x++)
                {
                if(v2[x] != v1[x]) return false;
                }
        return true;
        }

public void assignLeafNumbersBuildClusters(int num, int counter[])
                {
                cluster = new boolean[num];

                if(this.isLeaf())
                        {
                        this.num = counter[0]++;
                        cluster = new boolean[num];
                        cluster[this.num] = true;
                        }
                else
                        {
                        for(int x=0; x<children.size(); x++ )
                                {
                                Tree child = (Tree) children.elementAt(x);
                                child.assignLeafNumbersBuildClusters(num,counter);
                                for(int y=0; y<num; y++)
                                        {
                                        this.cluster[y] = child.cluster[y] || this.cluster[y];
                                        }
                                }

                        }

                }


//! ----------------------
        public Tree findLeaf(String str)
                {
                if( this.isLeaf() )
                        {
                        if( name.equals(str) ) return this;
                        return null;
                        }
                else
                        {
                        for(int x=0; x<children.size(); x++ )
                                {
                                Tree child = (Tree) children.elementAt(x);
                                Tree gotIt = child.findLeaf(str);
                                if( gotIt != null ) return gotIt;
                                }
                        return null;
                        }
                }
//! ---------------------

        public void buildClusters(int n)
                {
                cluster = new boolean[n];

                if( this.isLeaf() )
                        {
                        cluster[num] = true;
                        }
                else
                        {
                        for(int x=0; x<children.size(); x++ )
                                {
                                Tree child = (Tree) children.elementAt(x);
                                child.buildClusters(n);
                                for( int y=0; y<child.cluster.length; y++ )
                                        {
                                        if( child.cluster[y] ) cluster[y] = true;
                                        }
                                }
                        }
                }






        public Tree copy(Tree findMe[], String huntMe)
                {
                Tree me = new Tree();
                me.isLeaf = this.isLeaf;
                me.parent = null;
                me.name = this.name;
                me.num = this.num;

                if( (me.name != null) && (huntMe != null))
                        {
                        if( me.name.equals(huntMe) ) findMe[0] = me;
                        }

                if( this.children == null )
                        {
                        me.children = null;
                        return me;
                        }

                me.children = new Vector();
                for(int x=0; x<this.children.size(); x++ )
                        {
                        Tree c = (Tree) this.children.elementAt(x);
                        Tree cop = c.copy( findMe, huntMe );
                        cop.parent = me;
                        me.children.addElement( cop );
                        }

                return me;
                }

        //! returns true if a is an ancestor of b
        public static boolean isAncestorOf( Tree a, Tree b )
                {
                Tree scan = b;

                do      {
                        if( scan == a ) return true;
                        scan = scan.parent;
                        }
                while( scan != null );

                return false;
                }

        public void deleteChild(Tree c)
                {
                children.removeElement(c);
                }

        public void addChild( Tree c )
                {
                if( children == null )
                        {
                        children = new Vector();
                        }

                children.add(c);
                }

        public Tree getParent()
                {
                return parent;
                }

        //! Only relevant for leaves
        public void setName( String s )
                {
                name = s;
                }

        //! Only relevant for leaves
        public String getName()
                {
                return name;
                }

        //! Only relevant for leaves
        public void setNumber(int n)
                {
                num = n;
                //! System.out.println("A leaf is receiving number: "+num);
                }

        public Vector getChildren()
                {
                return children;
                }

        public void setParent( Tree p )
                {
                this.parent = p;
                }

        public boolean isLeaf()
                {
                return (children==null);
                }

        public boolean isRoot()
                {
                return( parent == null );
                }

        //! if the root of the tree changes, it returns the new root, otherwise null
        public Tree delete()
                {
                Tree p = this.parent;

                p.children.removeElement( this );

                if( p.children.size() > 1 ) return null;

                if( p.children.size() == 0 )
                        {
                        System.out.println("Catastrophic error. We encountered a parent node with outdegree 1.");
                        System.exit(0);
                        }

                //! So, parent now has 1 child, suppress....
                Tree sibling = (Tree) p.children.elementAt(0);

                Tree grandparent = p.parent;

                if( grandparent != null )
                        {
                        grandparent.children.removeElement( p );
                        grandparent.children.addElement( sibling );
                        sibling.parent = grandparent;
                        return null;
                        }
                else
                        {
                        //! It was the root...the sibling becomes the new root...
                        sibling.parent = null;
                        return sibling;
                        }

                }

        public void dump()
                {
                if(!isLeaf()) System.out.print("(");
                boolean begun = false;
                if(!isLeaf())
                        for(int x=0; x<children.size();x++)
                                {
                                if( begun ) System.out.print(",");
                                Tree t = (Tree) children.elementAt(x);
                                t.dump();
                                begun = true;
                                }

                if( this.isLeaf() ) System.out.print(name);
                if(!isLeaf()) System.out.print(")");
                }


        public void getLeafDescendants( Vector v )
                {
                if( this.isLeaf() )
                        {
                        v.addElement(this);
                        return;
                        }
                else
                        {
                        for(int x=0; x<children.size();x++)
                                {
                                ((Tree) children.elementAt(x)).getLeafDescendants(v);
                                }
                        }
                }


        public void harvestLocalMinimal(Vector v1)
                {
                if( this.isLeaf() ) return;

                boolean meMinimal = true;

                for(int x=0; x<children.size(); x++ )
                        {
                        Tree child = (Tree) children.elementAt(x);
                        if( child.isLeaf() == false )
                                {
                                meMinimal = false;
                                child.harvestLocalMinimal(v1);
                                }
                        }
                if( meMinimal )
                        {
                        v1.add(this);
                        }
                }

        public int countLeafDescendants()
                {
                if( this.isLeaf() ) return 1;

                int sum = 0;
                for(int x=0; x<children.size();x++)
                        {
                        sum += ((Tree) children.elementAt(x)).countLeafDescendants();
                        }
                return sum;
                }

        public static void collapseMaxSTsets(Tree t1, Tree t2, Vector ST)
                {
                for(int y=0;y<ST.size();y++)
                        {
                        STset s = (STset) ST.elementAt(y);

                        int count[] = new int[1];
                        String combName = s.getTaxaString(count);
                        if(count[0] == 1) continue;     //! no need to collapse, it's a singleton

                        combName = "{" + combName + "}";

                        Tree colNodeT1 = new Tree();
                        colNodeT1.setName(combName);

                        Tree prune = s.quasiLCA[0];
                        for(int x=0; x<s.subtrees[0].size(); x++)
                                {
                                prune.children.removeElement((Tree) s.subtrees[0].elementAt(x));
                                }
                        if(prune.children.size() == 0)
                                {
                                prune.children = null;
                                prune.name = combName;
                                }
                        else
                                {
                                prune.children.addElement(colNodeT1);
                                colNodeT1.parent = prune;
                                }
                        //! -----------------------

                        Tree colNodeT2 = new Tree();
                        colNodeT2.setName(combName);

                        prune = s.quasiLCA[1];
                        for(int x=0; x<s.subtrees[1].size(); x++)
                                {
                                prune.children.removeElement((Tree) s.subtrees[1].elementAt(x));
                                }
                        if(prune.children.size() == 0)
                                {
                                prune.children = null;
                                prune.name = combName;
                                }
                        else
                                {
                                prune.children.addElement(colNodeT2);
                                colNodeT2.parent = prune;
                                }


                        }


                }

        public Hashtable getLeafToTreeMapping()
                {
                Hashtable ht = new Hashtable();
                this.getLeafToTreeMapping(ht);
                return ht;
                }

        private void getLeafToTreeMapping(Hashtable ht)
                {
                if( this.isLeaf() )
                        {
                        ht.put( this.name, this );
                        }
                else
                        {
                        for(int x=0; x<children.size();x++)
                                {
                                ((Tree) children.elementAt(x)).getLeafToTreeMapping(ht);
                                }
                        }
                }

        public static Vector computeMaxSTsets(Tree t1, Tree t2)
                {
                Vector v1 = new Vector();
                t1.getLeafDescendants(v1);

                Vector v2 = new Vector();
                t2.getLeafDescendants(v2);

                //! System.out.println(v1.size());
                //! System.out.println(v2.size());

                Vector ST = new Vector();

                for(int x=0; x<v1.size(); x++)
                        {
                        //! System.out.println("Constructing singleton ST-set.");

                        STset s = new STset();
                        Tree leaf = (Tree) v1.elementAt(x);

                        s.subtrees[0].addElement(leaf);

                        s.quasiLCA[0] = leaf.parent;

                        for( int y=0; y<v2.size(); y++ )
                                {
                                Tree blad = (Tree) v2.elementAt(y);
                                //! System.out.println(blad.name);
                                if( blad.name.equals( leaf.name ) )
                                        {
                                        //! System.out.println("Found corresponding taxon in tree 2.");
                                        s.subtrees[1].addElement(blad);
                                        s.quasiLCA[1] = blad.parent;
                                        break;
                                        }
                                }
                        ST.addElement(s);
                        }

                //! We now have our initial set of ST-sets.

                boolean merged = true;

                while(merged)
                        {
                        merged = false;

                        if( ST.size() == 1 ) return ST; //! compatible!

                        outer: for(int x=0; x<ST.size(); x++ )
                                for(int y=(x+1); y<ST.size(); y++ )
                                        {
                                        STset A = (STset) ST.elementAt(x);
                                        STset B = (STset) ST.elementAt(y);

                                        if( (A.quasiLCA[0] == B.quasiLCA[0]) && (A.quasiLCA[1] == B.quasiLCA[1]) )
                                                {
                                                merged = true;

                                                STset AB = new STset(A,B);
                                                ST.removeElement(A);
                                                ST.removeElement(B);
                                                ST.addElement(AB);
                                                break outer;
                                                }
                                        }

                        }
                return ST;
                }

        public void harvestTaxa( StringBuffer sb, int count[])
                {
                if( this.isLeaf() )
                        {
                        sb.append(" "+this.name+" ");
                        count[0]++;
                        return;
                        }
                else
                        {
                        for(int x=0; x<children.size();x++)
                                {
                                ((Tree) children.elementAt(x)).harvestTaxa(sb, count);
                                }
                        }
                }

        //! This ASSUMES THEY ARE COMPATIBLE!
        public static Tree commonRefinement( Tree t1, Tree t2 )
                {
                Vector ST = Tree.computeMaxSTsets(t1,t2);
                if( ST.size() != 1 )
                        {
                        System.out.println("Tried to find common refinement of two non-compatible trees. Exiting.");
                        System.exit(0);
                        }
                Tree t = ((STset) (ST.elementAt(0))).makeTree();
                return t;
                }


        public static Tree restrict( Tree orig, Hashtable resTaxa )
                {
                String s[] = new String [resTaxa.size()];
                int counter = 0;

                Enumeration e = resTaxa.keys();
                while( e.hasMoreElements() )
                        {
                        s[counter++] = (String) e.nextElement();
                        }
                return Tree.restrict( orig, s );
                }


        public static Tree restrict( Tree orig, String resTaxa[] )
                {
                Tree stripT1 = orig.copy(null, null);

                Hashtable hT1 = stripT1.getLeafToTreeMapping();

                //! These are the things we *shouldn't* delete...
                Hashtable want = new Hashtable();
                for(int x=0; x<resTaxa.length; x++)
                        {
                        want.put(resTaxa[x],resTaxa[x]);
                        }

                Enumeration e = hT1.keys();
                while( e.hasMoreElements() )
                        {
                        String seek = (String) e.nextElement();
                        if( want.get(seek) != null ) continue;

                        Tree kill1 = (Tree) hT1.get(seek);

                                if(kill1 == null)
                                        {
                                        System.out.println("Catastrophic error looking for: "+seek+" ... "+kill1);
                                        System.exit(0);
                                        }
                        Tree temp = kill1.delete();
                        if( temp != null ) stripT1 = temp;
                        }
                return stripT1;
                }

        //! -------------------------------------------------------------

        public void dumpEnewick()
                {
                int lab[] = new int[1];
                lab[0] = 1;     //! numbering of hybridization nodes starts at 1

                this.allocateHybLabel(lab);

                System.out.print("// ");

                this.internalENewickDump();

                System.out.println("root;");
                }

        private void internalENewickDump()
                {
                if(this.isLeaf())
                        {
                        System.out.print(name);
                        return;
                        }

                System.out.print("(");

                for(int x=0; x<children.size();x++)
                        {
                        if( x!=0 ) System.out.print(",");
                        Tree c =(Tree) children.elementAt(x);
                        if( c.netParent[0] == this ) c.internalENewickDump();
                        else
                        if( c.netParent[1] != null )
                                {
                                if( c.netParent[1] == this )
                                        {
                                        System.out.print("#H"+c.hybLabel);
                                        }
                                else
                                        {
                                        System.out.println("CATASTROPHIC ERROR (1) with reticulation node parent.");
                                        System.exit(0);
                                        }
                                }
                        else
                                {
                                System.out.println("CATASTROPHIC ERROR (2) with reticulation node parent.");
                                System.exit(0);
                                }

                        }

                System.out.print(")");
                if(this.netParent[1] != null)
                        {
                        System.out.print("#H"+hybLabel);
                        }

                }

        public void allocateHybLabel(int label[])
                {
                if( this.isLeaf() ) return;

                //! If it's a hybrid node, give it a number
                if( netParent[1] != null )
                        {
                        hybLabel = label[0]++;
                        }

                for(int x=0; x<children.size();x++)
                        {
                        Tree c =(Tree) children.elementAt(x);
                        if( c.netParent[0] == this ) c.allocateHybLabel(label);
                        }
                }




        //! ---------------------------------------------------------------


        //! These functions are only used when the tree nodes are part of a network

        //! This visits every node of the network only once, by traversing a canonical spanning tree

        public void cleanNetwork(Hashtable nameToLeaf, int count[] )
                {
                visited = false;

                netClus = null;

                if( this.isLeaf() )
                        {
                        //! record it in the hashtable
                        if(nameToLeaf != null) nameToLeaf.put( this.name, this );
                        this.num = count[0]++;

                        return;
                        }

                if(children.size() > 2 )
                        {
                        System.out.println("CATASTROPHIC ERROR: shouldn't have nodes with outdegree > 2 at this point!");
                        System.exit(0);
                        }

                for(int x=0; x<children.size();x++)
                        {
                        Tree c =(Tree) children.elementAt(x);

                        if( c.netParent[0] == this ) c.cleanNetwork(nameToLeaf, count); //! has the effect of only visiting
                                                                                                                                                //! treenodes and reticulations via their left edge

                        if( (c.netParent[0] != this) && (c.netParent[1] != this) )
                                {
                                System.out.println("CATASTROPHIC ERROR: is not registered as either parent of a retic node.");
                                System.exit(0);
                                }
                        }

                }

//! ----------------------

//! Assumes the nodes have been numbered via dumpNetwork()

public void dumpNetworkTreeImage(int tree)
        {
        int count[] = new int[1];
        count[0] = 1000;

        System.out.println("strict digraph G"+(tree+1)+" {");

        this.numberForDumping(null);

        this.dumpArcsTreeImage(tree);

        System.out.println("}");
        }

//! -------------------------------------------

public void dumpNetwork()
        {
        int count[] = new int[1];
        count[0] = 1000;

        System.out.println("strict digraph G0 {");

        this.numberForDumping(count);

        this.dumpArcs();

        System.out.println("}");
        }

//! ----------------------------
private void dumpArcs()
        {
        if(this.isLeaf()) return;

        for(int x=0; x<children.size();x++)
                {
                Tree c =(Tree) children.elementAt(x);

                if( c.netParent[0] == this ) c.dumpArcs();
                System.out.println(this.printNum + " -> " + c.printNum);
                }
        }

//! ----------------------------------
//! This needs to be improved to colour the edges properly...

private void dumpArcsTreeImage(int tree)
        {
        if(this.isLeaf()) return;

        for(int x=0; x<children.size();x++)
                {
                Tree c =(Tree) children.elementAt(x);

                if( c.netParent[0] == this ) c.dumpArcsTreeImage(tree);

                if( c.netParent[1] == null) System.out.println(this.printNum + " -> " + c.printNum + " [color=blue]");
                else    {
                                if(c.netParent[tree] == this ) System.out.println(this.printNum + " -> " + c.printNum + " [color=blue]");
                                else System.out.println(this.printNum + " -> " + c.printNum + " [color=red]");
                                }

                }
        }



//! ----------------------------------

private void numberForDumping(int count[])
        {
        if(count != null) printNum = count[0]++;

        if(this.isLeaf())
                {
                System.out.println(printNum + " [shape=circle, width=0.3, label=\u005c""+this.name+"\u005c"];");
                }
        else
                {
                System.out.println(printNum + " [shape=point];");
                }

        if(!this.isLeaf())
        for(int x=0; x<children.size();x++)
                {
                Tree c =(Tree) children.elementAt(x);

                if( c.netParent[0] == this ) c.numberForDumping(count);
                }
        }




//! -----------------------

        public void buildOneSidedClusters(int side, int taxa)
                {
                if(netClus == null)
                        {
                        netClus = new boolean[2][taxa];
                        }

                if( this.isLeaf() )
                        {
                        netClus[side][this.num] = true;
                        return;
                        }

                if(children.size() > 2 )
                        {
                        System.out.println("CATASTROPHIC ERROR: shouldn't have nodes with outdegree > 2 at this point!");
                        System.exit(0);
                        }

                for(int x=0; x<children.size();x++)
                        {
                        Tree c =(Tree) children.elementAt(x);

                        //! if c is a split node, do it anyway...
                        if( c.netParent[1] == null )
                                {
                                c.buildOneSidedClusters(side,taxa);
                                for( int y=0; y<taxa; y++)
                                        {
                                        this.netClus[side][y] = this.netClus[side][y] || c.netClus[side][y];
                                        }
                                }
                        else
                        if( c.netParent[side] == this )
                                {
                                c.buildOneSidedClusters(side,taxa);
                                for( int y=0; y<taxa; y++)
                                        {
                                        this.netClus[side][y] = this.netClus[side][y] || c.netClus[side][y];
                                        }
                                }
                        }

                }


}

//! --------------------------------

class STset
{
public Tree quasiLCA[];
Vector subtrees[];
STset children[];


public STset()
        {
        //! one per tree
        quasiLCA = new Tree[2];
        subtrees = new Vector[2];

        subtrees[0] = new Vector();
        subtrees[1] = new Vector();

        children = new STset[2];        //! used to build the tree that reflects the order they are merged
        }

public Tree makeTree()
        {
        if( children[0] == null )
                {
                Tree t = new Tree();
                t.name = ((Tree) (subtrees[0].elementAt(0))).name;

                t.netParent[0] = null;
                t.netParent[1] = null;

                return t;
                }
        else
                {
                Tree t = new Tree();
                Tree t1 = children[0].makeTree();
                Tree t2 = children[1].makeTree();
                t.addChild(t1);
                t.addChild(t2);

                t1.netParent[0] = t;
                t1.netParent[1] = null;

                t2.netParent[0] = t;
                t2.netParent[1] = null;

                return t;
                }
        }

public void dump()
        {
        if( children[0] != null )
                {
                System.out.print("<");
                children[0].dump();
                System.out.print(",");
                children[1].dump();
                System.out.print(">");
                }
        else
                {
                System.out.print(((Tree) (subtrees[0].elementAt(0))).name);
                }
        }

//! NEW IN VERSION 2 ---------



// ---------------------------------


//! count[] passes back the number of taxa in total that are seen
public String getTaxaString(int count[])
        {
        StringBuffer sb = new StringBuffer();
        //! sb.append('{');

        for(int x=0; x<subtrees[0].size(); x++ )
                {
                ((Tree) subtrees[0].elementAt(x)).harvestTaxa(sb, count);
                }
        //! sb.append('}');

        return sb.toString();
        }

//! merges A and B and remembers this

public STset(STset A, STset B)
        {
        quasiLCA = new Tree[2];
        subtrees = new Vector[2];
        children = new STset[2];

        children[0] = A;
        children[1] = B;

        for(int t=0; t<=1; t++ )
                {
                subtrees[t] = new Vector();
                quasiLCA[t] = A.quasiLCA[t];

                for(int x=0; x<A.subtrees[t].size(); x++ )
                        {
                        subtrees[t].addElement( A.subtrees[t].elementAt(x) );
                        }

                for(int x=0; x<B.subtrees[t].size(); x++ )
                        {
                        subtrees[t].addElement( B.subtrees[t].elementAt(x) );
                        }

                if( subtrees[t].size() == quasiLCA[t].children.size() )
                        {
                        if( quasiLCA[t].parent != null )
                                {
                                subtrees[t].removeAllElements();
                                subtrees[t].addElement( quasiLCA[t] );
                                quasiLCA[t] = quasiLCA[t].parent;
                                }
                        }
                }


        }

}
